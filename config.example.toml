[general]
## Attention: Match Lists and Cases!! ##
## defaults: num fields: 0, string fields: "", bool fields: false
## Changes to web, log, limiter and scheduler are only loaded during start! So please restart after changing

log_level = "Debug" #Info or Debug or Warning
db_log_level = "Info" #Info or Debug or Warning - debug makes system extremly slow
log_file_size = 20 # in MB
log_file_count = 10 # Number of old Log Files to keep
log_compress = true # Compress old Log Files
worker_default = 2
worker_metadata = 4
worker_files = 2
worker_parse = 2
worker_search = 2
webport  = "9090" #string!
webapikey = "mysecure" #url is http://<server>:<webport>/api/...?apikey=mysecure
concurrent_scheduler = 2 # only applies to search jobs - not for feed import or file scans
movie_meta_source_imdb = true #metadata priority: 1. imdb 2. tmdb 3. omdb  - imdb has no plot
movie_meta_source_tmdb = true #has most fields
movie_meta_source_omdb = false
movie_meta_source_trakt = true
movie_alternate_title_meta_source_imdb = true # use imdb for alternate title import
movie_alternate_title_meta_source_tmdb = true
movie_alternate_title_meta_source_omdb = false
movie_alternate_title_meta_source_trakt = true
serie_alternate_title_meta_source_imdb = true
serie_alternate_title_meta_source_trakt = true
movie_meta_source_priority = ["imdb","tmdb","trakt"] #,"tmdb","omdb","trakt"] #first to last - either remove entry here or disable them above - possible: imdb, omdb, tmdb, trakt
movie_parse_meta_source_priority = ["imdb","tmdb"] #,"tmdb"] #first to last - either remove entry here or disable them above - possible: imdb, omdb, tmdb, trakt
movie_rss_meta_source_priority = ["imdb"] #first to last - either remove entry here or disable them above, enabling apis makes rss searches slower - possible: imdb, omdb, tmdb, trakt
serie_meta_source_tmdb = true #add additional fields - default not to disable: tvdb
serie_meta_source_trakt = true #add additional fields - default not to disable: tvdb
scheduler_disabled = 'true' #on your very first run change to true - after your media is indexed set to false
omdb_apikey =  "insert" # insert your omdb apikey
themoviedb_apikey="insert" # insert your themoviedb apikey
trakt_client_id="insert" # insert your trakt apikey
failed_indexer_block_time = 1 # Number of minutes to skip indexer after a failed query - default 5
disable_parser_string_match = true #Disables String Matcher (Only Regex is used for matching) - UseRegex for qualities must be enabled
use_godir = true #if true use godirwalk - scans files slightly faster and might handle syms but uses more ram
move_buffer_size_kb = 10 # Buffer Size for File Move Jobs (in KB)

trakt_limiter_seconds=1 # will only change after restart
trakt_limiter_calls=20 # max limiter_calls in limiter_seconds
tvdb_limiter_seconds=1 # will only change after restart
tvdb_limiter_calls=10 # max limiter_calls in limiter_seconds
tmdb_limiter_seconds=1 # will only change after restart
tmdb_limiter_calls=20 # max limiter_calls in limiter_seconds
omdb_limiter_seconds=1 # will only change after restart
omdb_limiter_calls=10 # max limiter_calls in limiter_seconds

ffprobe_path="" #Path where the ffprobe file is located in (without the actual file) - Linux Users should install with package manager (ex. apt-get -y install ffmpeg) - Windows Users please download https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-github

##### imdb configuaration #####

[imdbindexer]
indexed_types=["movie","tvMovie"] #,"tvSeries","tvEpisode"] #other: movie, tvMovie, short, tvSeries, tvEpisode, video, videoGame, tvSpecial, tvMiniSeries ##over 5000000 tvepisodes - so please keep that in mind
indexed_languages=["DE","US","UK",'\N'] #other titles in different languages will not be imported \N==emtpy
index_full=true #short only imports imdbid and titles/years - full also votes ratings and stuff

[media]

##### movie configuarations #####
### [[ marks an array so you can specify multiple movie/serie categories - just copy the whole block

	[[media.movies]]
	name="EN"
	default_quality="sdtv" #if quality not found
	default_resolution="360p" #if resolution not found
	naming = '{Title} ({Year})/{Title} ({Year}) [{Resolution} {Quality} {Codec} {Audio} {Proper}] ({Imdb})' #use / as path separator #include imdb or tvdb for maximum compability
	template_quality="SD" # Map to qualities below	
	template_scheduler="Default" # Map to scheduler below	
	metadata_language="English" #language definition for tmdb
	metadata_title_languages=["US","UK"] #allow titles with the languages
	structure=true #false leaves the files where they were downloaded to
	search_missing_incremental = 20 #number of elements processed during incremental scans - x*number of lists!
	search_upgrade_incremental = 20 #number of elements processed during incremental scans
		[[media.movies.data]]
		template_path="en movies" #match to path template name
		[[media.movies.data_import]]
		template_path="en movies import" #match to path template name
		[[media.movies.lists]]
		name="EN Movies" #Use unique names to match in db   - dont use same name for series and movies
		enabled=true
		add_found=false #Add Found movies if not in DB?
		template_list="Movies" # Map to lists
		template_quality="SD" # Map to qualities below
		compare="false" # false = add only new entries - old ones will not be removed - currently not yet developed
		ignore_template_lists=[] # Map to name - if movie exists already in db it will be skipped
		replace_template_lists=["EN Watchlist"] # Map to name - if movie exists already in db it will be replaced	
		[[media.movies.notification]]
		template_notification="pushover"
		event="added_data" #added_download #added_list
		title="New Movie added in {Configuration}"
		message="{Title} - moved from {Source_Path} to {Target_Path}{Replaced}"
		replaced_prefix="replaced"
		[[media.movies.notification]]
		template_notification="csvmovies"
		event="added_data" #added_download #added_list
		message="{Title};{Year};{Imdb};{Source_Path};{Target_Path};{Replaced}"
	
	
##### serie configuarations #####

	[[media.series]]
	name="EN"
	default_quality="sdtv"
	default_resolution="480p"
	naming = '{Title}/Season {Season}/{Title} - {Identifier} - {EpisodeTitle} [{Resolution} {Quality} {Codec} {Audio} {Proper}] ({Tvdb})'
	naming_identifier = 'S{0Season}E{0Episode}(E{0Episode})' # in Brackets are Variants for MultiEpisodes - E{0Episode}(E{0Episode}) = E01E02E03... E{0Episode}(-E{0Episode}) = E01-E02-E03...
	template_quality="SDSeries" # Map to qualities below	
	template_scheduler="Default" # Map to scheduler below
	metadata_language="en" #tvdb title language
	metadata_source="tvdb"
	metadata_title_languages=["US","UK"] #allow titles with language
	structure=true
	search_missing_incremental = 20
	search_upgrade_incremental = 20
		[[media.series.data]]
		template_path="en series"
		[[media.series.data_import]]
		template_path="en series import"
		[[media.series.lists]]
		name="EN" #Use unique names to match in db
		enabled=true
		add_found=false #Add Found movies if not in DB?
		template_list="SeriesEN" # Map to lists
		template_quality="SDSeries" # Map to qualities below	

		
##### templates #####


### downloader ###

[[downloader]]
name="ennzbget"
type="nzbget" #Send Files to nzbget client
hostname="192.168.1.1:6789" # hostname:port
username="admin" #username
password="" #pwd
enabled=true #is downloader active?
add_paused=false #add download in paused state?
priority=0  #-100 (very low), -50 (low), 0 (normal), 50 (high), 100 (very high), 900 (force)
auto_redownload_failed = 'false' # unused
remove_failed_downloads = 'false' # unused

[[downloader]]
name="ensab"
type="sabnzbd" #Send Files to sabnzbd client (untested)
hostname="192.168.1.1:8080" #hostname:port
password="" #enter api key here
enabled=true
priority=0  #-100 = Default Priority (of category), -3 = Duplicate, -2 = Paused, -1 = Low Priority, 0 = Normal Priority, 1 = High Priority, 2 = Force

[[downloader]]
name="en"
type="drone" # Type drone saves nzbs to folder
enabled=true

[[downloader]]
name="endeluge" 
type="deluge" #Send Torrents or Magnet Urls to deluge client
hostname="192.168.1.1"
port=58846 # Daemon Port
username="localclient"
password="" #Password from auth file
enabled=true
add_paused=false
deluge_dl_to="/downloads/incomplete" # Download incomplete to path
deluge_move_after=true # Move Downloads to after finish? true-false
deluge_move_to="/Download/complete" # Move Downloads after finish - path
priority=0  #-100 (very low), -50 (low), 0 (normal), 50 (high), 100 (very high), 900 (force)
auto_redownload_failed = 'false' # unused
remove_failed_downloads = 'false' # unused

### lists ###

[[lists]]
name="Watchlist"
type="imdbcsv" # Import Imdb Watchlist (need to be public lists)
url="https://www.imdb.com/list/ls12345678/export"
enabled=true
exclude_genre=[] # Exclude Genres from import
include_genre=[] # Only import Movies with one of these Genres

[[lists]]
name="TraktUserMovie"
type="traktpublicmovielist" # Import Trakt Public User List
enabled=true
limit=20
min_votes=200 # Only import movies with at least x votes
min_rating=4.5 # Only import movies with a minimum rating of x.x 
exclude_genre=["Horror","Documentary"]
include_genre=[]
trakt_username="mytraktname"
trakt_listname="mytraktlist"
trakt_listtype="movie" #movie or show

[[lists]]
name="TraktUserShow"
type="traktpublicshowlist" # Import Trakt Public User List
enabled=true
limit=20
trakt_username="mytraktname"
trakt_listname="mytraktlist"
trakt_listtype="show" #movie or show

[[lists]]
name="TraktPopular"
type="traktmoviepopular" # Import Trakt Popular Movies
enabled=true
limit=20
min_votes=200 # Only import movies with at least x votes
min_rating=4.5 # Only import movies with a minimum rating of x.x 
exclude_genre=["Horror","Documentary"]
include_genre=[]

[[lists]]
name="TraktTrending"
type="traktmovietrending" # Import Trakt Trending Movies
enabled=true
limit=20
min_votes=200
min_rating=4.5
exclude_genre=["Horror","Documentary"]
include_genre=[]

[[lists]]
name="TraktAnticipated"
type="traktmovieanticipated" # Import Trakt Anticipated Movies
enabled=true
limit=20
min_votes=200
min_rating=4.5
exclude_genre=["Horror","Documentary"]
include_genre=[] 


[[lists]]
name="TraktPopularShows"
type="traktseriepopular" # Import Trakt Popular Movies
enabled=true
limit=20 # no votes or include/exlude here

[[lists]]
name="TraktTrendingShows"
type="traktserietrending" # Import Trakt Trending Movies
enabled=true
limit=20 # no votes or include/exlude here

[[lists]]
name="TraktAnticipatedShows"
type="traktserieanticipated" # Import Trakt Anticipated Movies
enabled=true
limit=20 # no votes or include/exlude here

[[lists]]
name="Series"
type="seriesconfig"
enabled=true
series_config_file="series.toml" # File with Series to fetch

### indexers ###

[[indexers]]
name="nzbgeek"
type="newznab"
url="https://api.nzbgeek.info"
apikey="" # The API Key
userid="0" # userid - might be needed for rss
enabled='true' # use this indexer for searches
rss_enabled='true' # use this indexer for rss
custom_api = '' # Does the indexer not use apikey as Parameter? ex. nzbfinder uses api_token
custom_url = '' # Does the indexer use a custom_url for API Calls - Specify as https://server/api?apikey=23333
custom_rss_url = '' # Does the indexer use a custom_url for RSS Calls - Specify as https://server/rss?apikey=23333
custom_rss_category = '' # Does the indexer use the default &t= Parameter for categories? ex. nzbfinder uses id
add_quotes_for_title_query='false' # does the indexer need quotes for title searches?
max_rss_entries = 100 #system retrieves 10*x entries at most - but stops at the last element from the previous scan
rss_entries_loop = 5 # x rss calls x=2 == 2 api calls with 2*maxrss results - will get all but only process until last processed item
limiter_seconds=1 # will only change after restart
limiter_calls=1 # max limiter_calls in limiter_seconds
use_presort='false' # Use presort folder for import 
max_age=2300 # Max Age of Published Release (in days) - skip or set to 0 to ignore

[[indexers]]
name="jackett1337x" ## Example for torrents via jackett
type="newznab"
url="http://192.168.1.1:9117/api/v2.0/indexers/1337x/results/torznab"
apikey="" #Enter Api Key
userid="0"
enabled='true'
add_quotes_for_title_query='false'
max_rss_entries = 100
rss_entries_loop = 2 # x rss calls x=2 == 2 api calls with 2*maxrss results - will get all but only process until last processed item
limiter_seconds=1
limiter_calls=1 # max limiter_calls in limiter_seconds

### paths ###

[[paths]]
name="de series"
path='/DE_Series' # Path to scan for files
allowed_video_extensions=['.avi','.mkv','.mp4','.divx','.m4v','.mpg'] # Video File Extensions
allowed_other_extensions=['.idx','.sub','.srt'] # Subtitle Extensions or other files to keep
allowed_video_extensions_no_rename=[] # same as above but the file will not be renamed - only moved
allowed_other_extensions_no_rename=[] # same as above but the file will not be renamed - only moved
disallowed=['codec.exe','setup.exe','/codec/','\codec\','If_you_get_error','password','cd1','cd2'] # if the import folder contains one of these strings - ignore it
blocked=["!old","@Recycle",".@__thumb"] #Ignored files folders on import
min_size = 70 # Minumum Release Size (only for Indexer Scans used)
max_size = 1500 # Maximum Release Size (only for Indexer Scans used)
upgrade='true' # Upgrade video files if better one found?
upgrade_scan_interval = 3 #Scan for Upgrades every x days - Scan oldest first
missing_scan_interval = 1 #Scan for Missing every x days - Scan oldest first
missing_scan_release_date_pre = 5 # Start scanning for missing entry x days before the release date - if this is 0 or not specified - all will be scanned
replace_lower='true' #Replace lower quality movies? - uses quality of specific movie
min_video_size = 70 # Minumum Video File Size - smaller ones will be deleted
cleanup_size_mb=25 #MB - delete source folder if size is less then after import
allowed_languages=['German','Deutsch','deu','ger',''] #uses fprobe to try and extract the audio language - if other is found download will not be imported - '' allows downloads without language name as audio stream
delete_disallowed=false # Delete Folders which contain one of disallowed # sourcepath
delete_wrong_language=false # Delete Videos which don't match one of allowed_languages (if defined) # targetpath
move_replaced=false #Move old media files to new location before structure
move_replaced_target_path="/media/movies/!replaced" #Move old media files to new location before structure (Path)
check_runtime = 'true' # should the runtime be checked?
max_runtime_difference = 15 #Number of minutes the runtime should be in ex Runtime=60 RealRuntime=45
delete_wrong_runtime = false # Delete Media if the runtime is not within the difference (+ and - is allowed) so if Runtime=50 and Difference=5 - all from 45-55 Minutes is ok
use_presort=false # Use Presort folder for storing structured media - set replace_lower to false!
presort_folder_path="/media/movies_presort" # Path to presort folder

### notifications ###
### Possible pushover and csv

[[notification]]
name="pushover"
type="pushover"
apikey=""
recipient=""

[[notification]]
name="csvmoviesde"
type="csv"
output_to="movedmovies-de.csv"

### regex ###

[[regex]] ## Define Required Strings and Rejected Strings - Will be compiled on start
name="deseries"
required=[
        '(?i)(\b|_)ger(man)?(\b|_)',
        '(?i)(\b|_)(deu|und|wie|der|das|ein|eine|videomann)(tsch)?(\b|_)']
rejected=['(?i)(\b|_)(2160p|810p|360p|pal|ntsc)(\b|_)',
        '(?i)(\b|_)(bonus|trailer|sample)(\b|_)',
        '(?i)(\b|_)extra(s)?(\b|_)',
        '(?i)(\b|_)(ac3)?md(\b|_)',
        '(?i)(\b|_)mic(dubbed)?(\b|_)',
        '(?i)(\b|_)(cd|disc|disk|dvd|part)[ .\-)]?(1|2|3|4|5|9|r)(\b|_)',
        '(?i)(_|-)(a|b|c|d)(\b|_)',
        '(?i)(\b|_)(imageset|getb8|1bet|galaxxxy|asap|3d)(\b|_)',
        '(?i)(\b|_)(fre|fr|truefr)(nch|sub|subs)?(\b|_)',
        '(?i)(\b|_)ita(lian)?(\b|_)',
        '(?i)(\b|_)spa(nish)?(\b|_)',
        '(?i)(\b|_)rus(ian)?(\b|_)',
        '(?i)(\b|_)kor(ean|sub|subs)?(\b|_)',
        '(?i)(\b|_)(dan|dk|pol)(ish|sub|subs)?(\b|_)',
        '(?i)(\b|_)swe(dish|sub|subs)?(\b|_)',
        '(?i)(\b|_)heb(rew|sub|subs|dub)?(\b|_)',
        '(?i)(\b|_)(tur|tr)(kish)?(\b|_)',
        '(?i)(\b|_)(dut|nl)(ch)?(\b|_)',
        '(?i)(\b|_)(castellano|tamil|hindi|nordic|br|JAPANESE|CHINESE)(\b|_)',
        '(?i)(\b|_)moto(2|3)(\b|_)',
        '(?i)(\b|_)sub(s|bed)?(\b|_)',
        '(?i)(\b|_)(webscr|screener|ts|r5)(\b|_)']

### qualities ###

[[quality]]
name="HD"
wanted_resolution=['480p','720p','1080p']
wanted_quality=['hdtv','webdl','webrip','dvdrip','bluray']
wanted_codec=['h264','h265'] # Warning: Most release names don't have this and would be skipped ! Delete Row if possible
wanted_audio=['mp3','ac3'] # Warning: Most release names don't have this and would be skipped ! Delete Row if possible
cutoff_quality = 'bluray' # only upgrade until this quality is reached
cutoff_resolution = '720p'
exclude_year_from_title_search=true # title based searches include year - set to yes to disable (if yes make sure you have checkyear active)
backup_search_for_title=true # if true not only search for id (imdb, thetvdb) but also search for the title
backup_search_for_alternate_title=true # also search for all alternate titles (massive API calls!)
check_title=true #checks if the title is correct (also for imdb search)
check_year=true #checks if the year is correct (also for imdb search)
check_year1=true #checks if the year is correct allow+-1 (also for imdb search)
check_until_first_found=false #true = on use first available release and dont try the other indexers
title_strip_suffix_for_search=[" dc", "repack", "unrated", "directors cut", "THEATRICAL"] #removes strings from title-end for title searches
title_strip_prefix_for_search=["Uploader.presents", "Uploader presents"] #removes strings from title-start for title searches
		
	[[quality.reorder]] # Look into schema/db/000001_initialize.up.sql at the end for qualities their names and default priorities
	type="resolution"
	name="1080p"
	new_priority=5400
	[[quality.reorder]] # check api Endpoint /quality/quality_<name>/movie_<movieconfigname> or /quality/quality_<name>/serie_<serieconfigname> for priorities
	type="position" #multiplies names priority by x
	name="quality"
	new_priority=11
	[[quality.reorder]]
	type="combined_res_qual" #set combined priority for (Name = resolution, quality) this way you can arrange qualities a bit more freely
	name="480p,bluray" #enter in form: resolution,quality (no spaces - 1 Comma)
	new_priority=110000000
	[[quality.indexers]]
	template_indexer="nzbgeek" # Map to indexer	- 
	template_downloader="en"  # Map to downloader - must be correct type (newnab/usenet - tornab/torrent)
	template_regex="en" # Map to Regex
	template_path_nzb="en movies nzb"
	category_dowloader="Movies"
	additional_query_params="&extended=1&maxsize=6291456000"
	skip_empty_size=true # remove results without a size attribute
	history_check_title=true # if title is already in history skip release - default: only check url (same release will be downloaded from different indexers)
	categories_indexer="2030,2035,2040,2045" #, separated - no array

### scheduler ###
## A Scheduler with the Name "Default" is required - additional schedulers are possible

[[scheduler]]
name="Default" #support only m, d, h, s (Minute, Day, Hour, Second) currently - custom stuff not
interval_feeds="2h" #leave empty to disable - import new movies into db from feeds
interval_imdb="3d" #leave empty to disable - refresh imdb cache every ... (only Default Scheduler)
interval_feeds_refresh_movies="1d" # refreshes 100 movies only
interval_feeds_refresh_movies_full="10d"
interval_feeds_refresh_series="1d" # refreshes 20 series only
interval_feeds_refresh_series_full="7d"
interval_indexer_missing="30m" #this only scans for ids - no name scanning!
interval_indexer_upgrade="45m"
interval_indexer_missing_full="14d" # the normal scan only scans the configured amount - this scans all
interval_indexer_upgrade_full="30d"
interval_indexer_missing_title="90m" #this scans for ids and names!
interval_indexer_upgrade_title=""
interval_indexer_missing_full_title=""
interval_indexer_upgrade_full_title=""
interval_indexer_rss="15m" # rss search for missing / upgradable media
interval_scan_data="60m" # checks for new files in media directories
interval_scan_data_import="15m" # checks for newly finished and ready to import media
interval_scan_data_missing="3d" # checks for removed media